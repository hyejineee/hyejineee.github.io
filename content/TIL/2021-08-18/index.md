---
title: "20210818 TIL"
path: blog/TIL/20210818
tags: [TIL]
cover:  "./TIL.png"
date: 2021-08-18
excerpt: 도메인 주도 설계 스터디, 그래프 탐색 알고리즘 
draft: false
---

## Facts

* 도메인 주도 설계 6장 읽기 
* 그래프 탐색 알고리즘 복습
    * bfs, dfs를 복습하고 정리한 글을 포스팅했습니다.
    * 다익스트라 알고리즘을 복습했습니다.

## Feelings

* 그래프 탐색 알고리즘에 대해서 복습을 마쳤습니다. 재귀로 작성했는데 while문을 사용해서 작성한 것 보다 코드가 훨씬 보기 편합니다. 이제 그래프 탐색과 관련된 문제들을 풀어보고 어떻게 문제를 푸는지 감을 익혀야겠습니다. 

* 탐색 알고리즘을 복습하고 다시 혼자 힘으로 만들어 볼 수 있어서 기분이 좋습니다!!

* 도메인 주도 설계 스터디를 진행했습니다. 애그리게이트에 대한 예제를 팀원들과 다시 볼 수 있고 다시 이해할 수 있어서 좋았습니다. 

* 병호님의 포모도로 도메인 주도 설계를 봤습니다. 안드로이드로 포모도로를 만들면서 도메인 주도 설계를 해보고싶습니다. 


## Findings

* 도메인 주도 설계 6장 : 도메인 객체의 생명주기 
    * 객체들을 관리하는 데 실패한다면 model-dreven-design을 시도하는 것이 쉽게 좌절될 수 있다.
    * 도메인 객체와 관련된 문제 
        1. 생명주기 동안의 무결성 유지하기 
        2. 생명주기 관리의 복잡성으로 모델이 난해해지는 것을 방지하기 
    * 위의 문제를 해결하는 패턴 : Aggregate, Factory, Repository
    * Aggregate를 모델링하고 설계에 Factory와 Repository를 추가하면 모델 객체의 생명주기 동안 그것들을 체계적이고 의미 있는 단위로 조작할 수 있다.

    * Aggregate : 데이터 변경의 단위로 다루는 연관 객체의 묶음.
        * 모델 내에서 복잡한 연관관계를 맺는 객체를 대상으로 변경의 일관성을 보장하기 어려움. => 밀접한 관계에 있는 객체 집합에도 불변성이 유지돼야 하기 때문.
        * 소유권과 경계를 명확히 정의함으로써 모델을 엄격하게 만들어 객체 간의 연관관계가 혼란스럽게 얽히지 않게 한다.
        * 각 Aggregate에는 루트와 경계가 있다. 
            * 경계는 Aggregate에 무엇이 포함되고 포함되지 않는지를 정의한다.
            * 루트는 단 하나만 존재한다. Aggregate에 포함된 특정 엔티티를 가리킨다. 
            * 경계 안의 객체는 서로 참조할 수 있지만 경계 밖의 객체는 해당 Aggregate의 구성요소 가운데 루트만 참조할 수 있다.
            * 해당 Aggregate의 경계 밖에 위치한 객체는 루트 엔티티의 컨텍스트 말고는 Aggregate의 내부를 볼 수 없다.
        * Aggregate의 각 요소를 아래와 같이 배치하면 Aggregate안의 객체와 전체로서의 Aggregate의 상태를 변경할 때 모든 불변식을 효과적으로 이행할 수 있다.
            * 엔티티와 값객체를 Aggregate로 모으고 각각에 대해 경계를 정하라.
            * 한 엔티티를 골라 Aggregate의 루트로 만들고 Aggregate의 경계 내부의 객체에 대해서는 루트를 거쳐 접근할 수 있게 하라.
            * Aggregate 밖의 객체는 루트만 참조할 수 있게 하라.
            * 루트를 경유하지 않고는 Aggregate의 내부를 변경할 수 없다.
        * 생명주기 전 단계에서 불변식이 유지돼야 할 범위를 표시해준다.

    * Factory : 객체 생명주기의 초기 단계 
        * 어떤 객체나 Aggregate를 생성하는 일이 복잡해지거나 내부 구조를 많이 드러내는 경우 Factory가 캡슐화를 제공해준다.
        * 클라이언트에서 직접 필요로 하는 객체를 생성하면 클라이언트 설계가 지저분해지고 조립되는 객체나 Aggregate의 캡슐화를 위반하며, 클라이언트와 생성된 객체의 구현이 지나치게 결합된다.
        * Factory를 잘 설계하기 위한 두 가지 기본 요건 
            1. 각 생성 방법은 원자적 이어야 하며, 생성된 객체나 Aggregate의 불변식을 모두 지켜야한다.Factory는 일관성 있는 상태에서만 객체를 만들어 낼 수 있어야 한다.
            2. Factory는 생성된 클래스보다는 생성하고자 하는 타입으로 추상화돼야 한다.

    * Repository : 객체 생명주기의 중간과 마지막 단계
        * 기술적 문제에 벗어나서 다시 모델에 집중하게 해주는 단순한 개념적 틀
        * Repository의 이점 
            * 영속화된 객체를 획득하고 해당 객체의 생면주기를 관리하기 위한 단순한 모델을 클라이언트에 제시한다.
            * 영속화 기술과 다수의 데이터베이스 전력, 또는 심지어 다수의 데이터 소스로부터 애플리케이션과 도메인 설계를 분리해준다.
            * 객체 접근에 관한 설계 결정을 전해준다.
            * repository를 이용하면 테스트에서 사용할 가짜 구현을 손쉽게 대체할 수 있다.

* [그래프 탐색 알고리즘 1 : 너비 우선 탐색, 깊이 우선 탐색](https://hyejineee.github.io/blog/graph-search-algorithm1)

* [그래프 탐색 알고리즘 2 : 최단 경로 알고리즘 - 다익스트라 알고리즘](https://hyejineee.github.io/blog/graph-search-algorithm2)

## Future Action Plans

* 패캠 강좌를 보면서 안드로이드 클린 아키텍처 TODO를 만듭니다.
* 코틀린 동시성 프로그래밍에 예제를 mvvm 아키텍처로 리팩터링 합니다.
* 도메인 주도 설계 2주차 스터디 후기를 작성합니다. 
* 코틀린 동시성 프로그래밍에 대한 글 초안을 만듭니다.







