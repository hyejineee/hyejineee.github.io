---
title: '[러닝 타입스크립트] 07. 인터페이스'
path: blog/reading/learning-typescript-07
tags: [Reading]
cover: './cover.png'
date: 2023-02-16
excerpt: 읽고 또 읽어야지 라는 생각으로 빠르게 읽는 러닝 타입스크립트
---

 * 타입 별칭 vs 인터페이스 
	* 인터페이스는 선언 병합이 가능하지만, 타입 별칭은 선언 병합이 불가하다.

	* 인터페이스는 클래스가 선언된 구조의 타입을 확인하는 데 사용할 수 있지만, 타입 별칭은 사용할 수 없다. -> ?

	* 일반적으로 인터페이스에서 타입 검사기가 더 빨리 작동한다. -> 인터페이스가 내부적으로 더 쉽게 캐시할 수 있는 명명된 타입을 선언한다.

	* 인터페이스는 이름 없는 객체 리터럴의 별칭이 아닌 이름 있는(명명된) 객체로 간주 -> 오류 메세지를 쉽게 읽을 수 있음.

* 인터페이스 속성 선언
	* ?를 사용하여 선택적 속성 선언
	* readonly 키워드로 읽기 전용 속성 선언
		* readonly 제한자는 타입 시스템에만 존재하며 인터페이스에서만 사용할 수 있음
		* 컴파일된 자바스크립트 출력 코드에 존재하지 않음.
		* readonly는 단지 타입스크립트 타입 검사기를 사용해 개발 중에 그 속성이 수정되지 못하도록 보호하는 역할을 한다.

* 인터페이스 멤버를 함수로 선언하는 3가지 방법 - 메서드 구문, 속성 구문, 호출 시그니처
	* 메서드 구문 : 인터페이스 멤버를 number() : void 와 같이 객체의 멤버로 호출되는 함수로 선언
	* 속성 구문  : 인터페이스 멤버를 number : () => void 와 같이 독립 함수와  동일하게 선언
	* 호출 시그니처 
		* 함수의 타입을 표현하는 방법 -> 타입 스크립트에서 함수의 타입을 지정할 때 사용하는 문법

		```js
		interface Test {
			property : (input : number) => string; // 속성 구문 
			method (input : number) : string; // 메서드 구문
			(input : number) : string // 호출 시그니처
		}
		```
	* 메서드 구문과 속성 구문의 차이점 
		* 메서드는 readonly 제한자를 사용할 수 없다. 속성은 가능 

		* 인터페이스의 선언 병합은 메서드와 속성을 다르게 처리함. 
			* 병합된 인터페이스는 동일한 이름의 속성을 여러번 선언할 수 없음. -> 오버로드 불가 
			* 메서드는 오버로드 가능 -> 동일한 이름과 다른 시그니처를 가진 메서드 정의할 수 있음.

		* 타입에서 수행되는 일부 작업은 메서드와 속성을 다르게 처리함.

	* 메서드 구문과 속성 구문 선택 기준 : 기본 함수가 this를 참조할 수 있다는 것을 알고 있다면 메서드 함수 사용

* 인덱스 시그니처
	* 인터페이스의 객체가 임의의 키를 받고, 해당 키 아래의 특정 타입을 반환할 수 있음을 나타냄

	```js
	// string 타입을 키의 타입으로 사용하는 속성은 모두 number를 반환해야 함.
	interface Test{
		[key : string] : number;
	}
	```

	* 인덱스 시그니처는 객체에 값을 할당할 때 편리하지만 타입 안정성을 완벽하게 보장하지는 않는다. -> 객체 내부에 정의되지 않은 키에 대한 접근을 컴파일 시점에서 제한하지 않음.

	* 숫자 인덱스 시그니처 : string 타입을 갖는 인덱스 시그니처 보다 더 많은 타입을 포괄해야 함.

* 확장 
	* extends 키워드를 사용해 확장할 수 있음. 
	* , (쉼표) 구분으로 다중 상속 가능
	* 재정의 가능 (오버라이딩) -> 파생 인터페이스 타입의 인스턴스를 기본 인터페이스 타입에 할당할 수 있음. (리스코프 치환 가능)
	* 속성을 재선언하는 대부분의 파생 인터페이스는 해당 속성을 유니언 타입의 더 구체적인 하위 집합으로 만들거나 속성을 기본 인터페이스의 타입에서 확장된 타입으로 만들기 위해 사용한다.

* 병합 
	* 인터페이스는 선언 병합이 가능함 
	* 같은 이름의 속성을 갖는 인터페이스를 병합할 경우 오류 발생 
	* 하지만 같은 이름을 갖는 메서드를 갖는 인터페이스를 병합할 경우 오류 발생 안함 -> 오버로드
	```js
	interface Merged { fromFirst : string }
	interface Merged { fromSecond : number }
	-> 
	interface Merged {
		fromFirst : string;
		fromSecond : number;
	}
	```