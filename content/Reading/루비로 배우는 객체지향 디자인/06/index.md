---
title: '[루비로 배우는 객체지향 디자인] 06. 상속을 이용해 새로운 행동 얻기'
path: blog/reading/ood-in-ruby-6
tags: [Reading]
cover: './cover.png'
date: 2023-03-14
excerpt: 지속가능한 소프트웨어를 만드는 방법
---

* 기술적으로 올바른 상속의 위계구조를 만드는 법을 설명
* 공통된 행동을 많이 공유하고 있지만 특정 관점에서만 다르고, 동시에 서로 연관된 타입들을 다루는 문제. 상속은 이런 문제를 해결해 준다.
* 추상화된 상위 클래스를 만드는 가장 좋은 방법은 구체적인 하위클래스의 코드를 위로 올리는 것이다.
* 추상화된 상위 클래스는 템플릿 메서드 패턴을 이용해서 하위 클래스가 자신의 특수한 내용을 추가할 수 있도록 돕는다. 
* 훅 메서드를 이용하면 하위 클래스가 추상화 알고리즘을 알지 못해도 자신의 특수한 내용을 추가할 수 있다. -> 하위 클래스가 super를 전송하지 않아도 괜찮기 때문에 상속 관계의 층위 사이의 결합이 느슨해진다. 또한 수정을 잘 받아들일 수 있게 된다. 

* 전반적으로 이해가 잘 안된다🥲


## 상속이란? 
* 상속 시스템은 특정 객체가 이해할 수 없는 메시지를 전달받았을 경우 그 객체는 이 메시지를 다른 객체에게 전달한다. 
	* 하위 클래스에서 상위 클래스로 전달된다.
	* 다른 클래스로부터 속성과 메서드를 물려받는 것 
	* 자식 클래스는 부모 클래스의 특성을 상속받아 새로운 속성과 메서드를 추가하거나 기존의 것을 변경할 수 있다.

## 상속이 필요할 때 
* 상속을 통해 해결할 수 있는 문제
	* 밀접히 연관된 타입들이 같은 행동을 공유하고 있지만 특정한 관점에서는 다른 경우
	* 상속을 사용하기 이전의 코드 -> 속성을 통해 객체가 해야할 일을 정하는 코드. 자기가 어떤 종류인지 알고 있는 속성을 확인하는 if문을 포함하고 있음.
		* 객체는 수신자가 어떤 종류인지를 확인하고 어떤 메시지를 전송할지 결정한다. 
		* 네가 누구인지 알고있다. 때문에 네가 무엇을 하는지도 안다. -> 수정 비용을 높이는 의존성
* 상속 
	* 첫 번째 객체가 이해할 수 없는 메시지를 수신하면 이 객체는 다음 객체에게 자동으로 메시지를 전달한다. 
	* 이해하지 못하는 메시지가 상위클래스의 연쇄를 타고 올라간다는 사실은 하위클래스는 상위클래스의 모든 행동을 갖고 있다는 점, 그리고 추가적인 행동을 더 가지고 있다는 사실을 말해준다.
	* 하위 클래스는 상위 클래스의 특수한 형태

## 상속 제대로 사용하기 
* 잘못된 상속 
	* 클래스에 어울리는 행동이든 아니든 모든 행동을 상속받는다.
	* 상위 클래스에 제대로 된 행동을 정의해야 한다. 구체적인 행동을 포함하고 있을 경우 상속받은 다른 객체를 사용할 때 문제를 일으킬 수 있다.
	* 하위클래스는 상위클래스의 특수한 형태다. 
	* 상위클래스와 협업할 수 있는 모든 객체는 하위 클래스에 대해 아무것도 모른 채 하위 클래스와 협업할 수 있어야 한다. -> 상속에서 반드시 지켜야 하는 원칙!
	* 상속이 제대로 작동하려면 두 가지가 언제나 충족되어야 한다
		* 모델링하는 객체들이 명백하게 일반-특수 관계를 따라야 한다.
		* 올바른 코딩 기술을 사용해야 한다.

* 추상화지점 파악하기
	* **언제 추상화된 상위 클래스를 만들어야 하는가?**
		* 하나의 하위 클래스만을 갖는 추상화된 상위클래스를 만든느 것은 거의대부분의 경우 말이 안 된다.
		* 다른 종류의 하위클래스를 다뤄야 하는 요청에 직면하기 전까지는 현재의 클래스로 충분하다.
		* 상속 관계를 만드는 데는 높은 비용이 든다! 
		* 이 비용을 최소화하는 가장 좋은 방법은 하위클래스가 필요로 하기 바로 직전에 추상 클래스를 만드는 것이다. 
	* 어떻게 추상적인 행동을 만드는가?
		* 모두 아래로 내리고 그 다음에 필요한 것만 위로 올리기 전략 -> 구체적인 내용을 추상 클래스에 남겨 놓을 걱정을 하지 않아도 된다.
			* 때문에 구체적인 것을 내리기보다는 추상적인 것을 끌어올리는 방식을 취해야 한다.
		* **상속을 구현하는데 따르는 여러 어려움은 구체적인 것과 추상적인 것을 제대로 구분하지 못하는 데서 기인한다.**
	* 상속 관계의 구조를 알고 있어야 한다는 점, 이 지식 자체가 애플리케이션 곳곳에 스며들고 수정하기 힘든 의존성을 만들어 낸다. 
	
* 템플릿 메서드 패턴 
	* 기본 구조를 상위클래스가 정의하고 상위클래스에서 메시지를 전송하여 하위클래스의 특수한 값을 얻는 기술
	* 템플릿 메서드 패턴을 사용하는 클래스는 자신이 전송하는 메서드를 직접 구현해 놓아야 한다.
	* 상위클래스에서 공통의 알고리즘을 정의하고, 메시지 전송을 통해 하위클래스가 알고리즘에 개입할 수 있는 여지를 남겨준다.

## 상위클래스와 하위클래스의 커플링 관리
* 강하게 결합된 클래스는 독립적으로 수정할 수 없게 만든다.
* 상위클래스에 대한 지식이 의존성을 만들어 내고 두 클래스를 강하게 결합시킨다.
	* super를 사용하는 부분
	* 상위 클래스의 메서드를 그대로 호출하는 부분 -> 하위클래스가 추상화된 상위클래스와 어떻게 소통해야 하는지도 알아야할 때 문제가 발생한다.
* 훅 메시지를 사용해서 하위클래스의 결합 없애기
	* 훅메시지란?
		* 추상 클래스나 인터페이스에서 선언된 메서드 중에서 하위 클래스에서 구현할 수 있도록 설계된 메서드 
		* 템플릿 메서드 패턴에서 사용되는 기법 중 하나 -> 코드의 재사용성과 유연성이 높아지게 된다.